@page "/keygen"
@using GlitchEd25519 = global::GlitchEd25519
@using System.Security.Cryptography
@using GlitchedPolygons.ExtensionMethods
@inject IJSRuntime JSRuntime

<PageTitle>
    GlitchEd25519 - Keygen
</PageTitle>

<h1>
    Ed25519 Keygen
</h1>

<br />

<p>
    <strong>Private key is in Ref10 format and hex-encoded string</strong>
</p>

@if (DEBUG)
{
    <p role="status">
        Generated seed: @seed
    </p>
}

<p role="status">
    Generated public key hex string: @publicKeyHexString
</p>

<p role="status">
    Generated private key hex string:
    @if (privateKeyHexString.NotNullNotEmpty())
    {
        <i>(censored)</i>
    }
</p>

<button class="btn btn-primary"
        style="padding-left: 24px; padding-right: 24px;"
        @onclick="GenerateNewKeypair">
    Generate key pair
</button>

<button class="btn btn-primary"
        style="padding-left: 24px; padding-right: 24px;"
        @onclick="CopyPublicKey">
    Copy public key
</button>

<button class="btn btn-primary"
        style="padding-left: 24px; padding-right: 24px;"
        @onclick="CopyPrivateKey">
    Copy private key
</button>

@code {

    private readonly bool aesGcmSupported = AesGcm.IsSupported;

#if DEBUG
        private const bool DEBUG = true;
#else
        private const bool DEBUG = false;
#endif

    private string seed = string.Empty;
    private string additionalEntropy = string.Empty;
    private string publicKeyHexString = string.Empty;
    private string privateKeyHexString = string.Empty;

    private void GenerateNewKeypair()
    {
        Span<byte> generatedSeed = stackalloc byte[32];
        Span<byte> generatedPublicKey = stackalloc byte[32];
        Span<byte> generatedPrivateKey = stackalloc byte[64];
        Span<byte> additionalEntropyBytes = stackalloc byte[64];

        if (additionalEntropy.NullOrEmpty())
        {
            Random.Shared.NextBytes(additionalEntropyBytes);
        }

        SHA512.HashData(additionalEntropy.UTF8GetBytes(), additionalEntropyBytes);

        GlitchEd25519.CreateSeed(ref generatedSeed, additionalEntropyBytes);

#if DEBUG
        seed = Convert.ToHexString(generatedSeed);
#endif

        GlitchEd25519.CreateKeypairRef10(ref generatedPublicKey, ref generatedPrivateKey, generatedSeed);

        publicKeyHexString = Convert.ToHexString(generatedPublicKey);
        privateKeyHexString = Convert.ToHexString(generatedPrivateKey);

        CryptographicOperations.ZeroMemory(generatedSeed);
        CryptographicOperations.ZeroMemory(generatedPublicKey);
        CryptographicOperations.ZeroMemory(generatedPrivateKey);
        CryptographicOperations.ZeroMemory(additionalEntropyBytes);
    }

    private async Task CopyPublicKey()
    {
        await JSRuntime.InvokeVoidAsync("navigator.clipboard.writeText", publicKeyHexString);
        await JSRuntime.InvokeVoidAsync("alert", "Copied public key to clipboard. Send this to your recipient :)");
    }

    private async Task CopyPrivateKey()
    {
        await JSRuntime.InvokeVoidAsync("navigator.clipboard.writeText", privateKeyHexString);
        await JSRuntime.InvokeVoidAsync("alert", "Copied private key to clipboard. Keep this safe and secret; DO NOT SHARE!");
    }

}